use crate::{
    as_status, attestation::create_attestation_report_on, unix_now, BlockNumber, CesealClient, ChainQueryHelper,
    RpcResult, RpcStatusSource,
};
use anyhow::{anyhow, Result};
use ces_crypto::{
    aead,
    ecdh::EcdhKey,
    key_share,
    sr25519::{Persistence, KDF},
    SecretKey,
};
use ces_types::{
    attestation::{validate as validate_attestation_report, SgxFields},
    AttestationProvider, AttestationReport, ChallengeHandlerInfo, EncryptedKey, EncryptedWorkerKey, HandoverChallenge,
};
use cestory_api::handover::{self as pb, handover_api_server::HandoverApi};
use parity_scale_codec::{Decode, Encode};
use ring::rand::SecureRandom;
use sp_core::sr25519;
use tonic::{Request, Response, Status};

fn generate_random_info() -> [u8; 32] {
    let mut nonce_vec = [0u8; 32];
    let rand = ring::rand::SystemRandom::new();
    rand.fill(&mut nonce_vec).unwrap();
    nonce_vec
}

fn generate_random_iv() -> aead::IV {
    let mut nonce_vec = [0u8; aead::IV_BYTES];
    let rand = ring::rand::SystemRandom::new();
    rand.fill(&mut nonce_vec).unwrap();
    nonce_vec
}

pub struct HandoverServer {
    ceseal_client: CesealClient,
    cqh: ChainQueryHelper,
    handover_ecdh_key: Option<EcdhKey>,
    handover_last_challenge: Option<HandoverChallenge<BlockNumber>>,
}

impl HandoverServer {
    fn get_worker_key_challenge(&mut self, block_number: BlockNumber, now: u64) -> HandoverChallenge<BlockNumber> {
        let sgx_target_info = if self.dev_mode {
            vec![]
        } else {
            let my_target_info = sgx_api_lite::target_info().unwrap();
            sgx_api_lite::encode(&my_target_info).to_vec()
        };
        let challenge = HandoverChallenge {
            sgx_target_info,
            block_number,
            now,
            dev_mode: self.dev_mode,
            nonce: generate_random_info(),
        };
        self.handover_last_challenge = Some(challenge.clone());
        challenge
    }

    fn verify_worker_key_challenge(&mut self, challenge: &HandoverChallenge<BlockNumber>) -> bool {
        return self.handover_last_challenge.take().as_ref() == Some(challenge);
    }
}

#[tonic::async_trait]
impl HandoverApi for HandoverServer {
    /// Key Handover Server: Get challenge for worker key handover from another ceSeal
    async fn handover_create_challenge(&self, _: Request<()>) -> RpcResult<pb::HandoverChallenge> {
        let (block, ts) = self.cqh.current_block().await.map_err(as_status)?;
        let challenge = self.get_worker_key_challenge(block, ts);
        Ok(Response::new(pb::HandoverChallenge::new(challenge)))
    }

    /// Key Handover Server: Get worker key with RA report on challenge from another Ceseal
    async fn handover_start(
        &self,
        request: Request<pb::HandoverChallengeResponse>,
    ) -> RpcResult<pb::HandoverWorkerKey> {
        let request = request.into_inner();
        let id_key = self.ceseal_client.identity_key().await.map_err(as_status)?;
        let in_sgx = self.ceseal_client.is_sgx_env().await.map_err(as_status)?;
        let dev_mode = id_key.dev_mode;
        let (block_number, now_ms) = self.cqh.current_block().await.map_err(as_status)?;

        // 1. verify client RA report to ensure it's in sgx
        // this also ensure the message integrity
        let challenge_handler = request.decode_challenge_handler().map_err(as_status)?;
        let block_sec = now_ms / 1000;
        let attestation = if !dev_mode && in_sgx {
            let payload_hash = sp_core::hashing::blake2_256(&challenge_handler.encode());
            let raw_attestation = request
                .attestation
                .ok_or_else(|| anyhow!("Client attestation not found").as_status())?;
            let attn_to_validate =
                Option::<AttestationReport>::decode(&mut &raw_attestation.encoded_report[..]).map_err(as_status)?;
            // The time from attestation report is generated by IAS, thus trusted. By default, it's valid for **10h**.
            // By ensuring our system timestamp is within the valid period, we know that this ceseal is not hold back by
            // malicious workers.
            validate_attestation_report(attn_to_validate.clone(), &payload_hash, block_sec, false, vec![], false)
                .map_err(as_status)?;
            attn_to_validate
        } else {
            info!("Skip client RA report check in dev mode");
            None
        };
        // 2. verify challenge validity to prevent replay attack
        let challenge = challenge_handler.challenge;
        if !self.verify_worker_key_challenge(&challenge) {
            return Err(Status::invalid_argument("Invalid challenge"));
        }
        // 3. verify sgx local attestation report to ensure the handover ceseals are on the same machine
        if !dev_mode && in_sgx {
            let recv_local_report =
                unsafe { sgx_api_lite::decode(&challenge_handler.sgx_local_report).map_err(as_status)? };
            sgx_api_lite::verify(recv_local_report).map_err(as_status)?;
        } else {
            info!("Skip client LA report check in dev mode");
        }
        // 4. verify challenge block height and report timestamp
        // only challenge within 150 blocks (30 minutes) is accepted
        let challenge_height = challenge.block_number;
        if !(challenge_height <= block_number && block_number - challenge_height <= 150) {
            return Err(Status::invalid_argument("Outdated challenge"));
        }
        // 5. verify ceseal launch date, never handover to old ceseal
        if !dev_mode && in_sgx {
            let my_la_report = {
                // target_info and reportdata not important, we just need the report metadata
                let target_info = sgx_api_lite::target_info().expect("should not fail in SGX; qed.");
                sgx_api_lite::report(&target_info, &[0; 64])
                    //.context("Cannot read server ceseal info")
                    .map_err(as_status)?
            };
            let my_runtime_hash = {
                let sgx_fields = SgxFields {
                    mr_enclave: my_la_report.body.mr_enclave.m,
                    mr_signer: my_la_report.body.mr_signer.m,
                    isv_prod_id: my_la_report.body.isv_prod_id.to_ne_bytes(),
                    isv_svn: my_la_report.body.isv_svn.to_ne_bytes(),
                    report_data: [0; 64],
                    confidence_level: 0,
                };
                sgx_fields.measurement_hash()
            };
            let my_runtime_timestamp = self
                .cqh
                .get_ceseal_bin_added_at(&my_runtime_hash)
                .await
                .map_err(as_status)?
                .ok_or_else(|| Status::internal("Server ceseal not allowed on chain"))?;

            let attestation = attestation.ok_or_else(|| anyhow!("Client attestation not found").as_status())?;
            let req_runtime_hash = match attestation {
                AttestationReport::SgxIas { ra_report, signature: _, raw_signing_cert: _ } => {
                    let (sgx_fields, _) = SgxFields::from_ias_report(&ra_report)
                        .map_err(|_| anyhow!("Invalid client RA report").as_status())?;
                    sgx_fields.measurement_hash()
                },
                AttestationReport::SgxDcap { quote, collateral: _ } => {
                    let (sgx_fields, _) = SgxFields::from_dcap_quote_report(&quote)
                        .map_err(|_| anyhow!("Invalid client RA report").as_status())?;
                    sgx_fields.measurement_hash()
                },
            };
            let req_runtime_timestamp = self
                .cqh
                .get_ceseal_bin_added_at(&req_runtime_hash)
                .await
                .map_err(as_status)?;
                .ok_or_else(|| anyhow!("Client ceseal not allowed on chain").as_status())?;

            if my_runtime_timestamp >= req_runtime_timestamp {
                return Err(Status::internal("Same ceseal version or rollback ,No local handover provided"));
            }
        } else {
            info!("Skip ceseal timestamp check in dev mode");
        }

        // Share the key with attestation
        let ecdh_pubkey = challenge_handler.ecdh_pubkey;
        let iv = generate_random_iv();
        let (ecdh_pubkey, encrypted_key) = key_share::encrypt_secret_to(
            id_key.key_pair(),
            &[b"worker_key_handover"],
            &ecdh_pubkey.0,
            &SecretKey::Sr25519(id_key.dump_secret_key()),
            &iv,
        )
        .map_err(as_status)?;
        let encrypted_key = EncryptedKey { ecdh_pubkey: sr25519::Public::from_raw(ecdh_pubkey), encrypted_key, iv };
        let genesis_block_hash = self.ceseal_client.genesis_hash().clone();
        let encrypted_worker_key = EncryptedWorkerKey { genesis_block_hash, dev_mode, encrypted_key };

        let worker_key_hash = sp_core::hashing::blake2_256(&encrypted_worker_key.encode());
        let attestation = if !dev_mode && in_sgx {
            let a = self
                .ceseal_client
                .create_attestation_report(&worker_key_hash)
                .await
                .map_err(as_status)?;
            Some(pb::Attestation {
                provider: a.provider,
                encoded_report: a.encoded_report,
                timestamp: a.timestamp,
            })
        } else {
            info!("Omit RA report in workerkey response in dev mode");
            None
        };

        Ok(Response::new(pb::HandoverWorkerKey::new(encrypted_worker_key, attestation)))
    }
}

pub struct HandoverClient {
    ceseal_client: CesealClient,
    handover_ecdh_key: Option<EcdhKey>,
}

impl HandoverClient {
    /// Key Handover Client: Process HandoverChallenge and return RA report
    pub async fn handover_accept_challenge(
        &mut self,
        request: pb::HandoverChallenge,
    ) -> Result<pb::HandoverChallengeResponse> {
        // generate and save tmp key only for key handover encryption
        let handover_key = crate::new_sr25519_key();
        let handover_ecdh_key = handover_key.derive_ecdh_key().expect("should never fail with valid key; qed.");
        let ecdh_pubkey = ces_types::EcdhPublicKey::from_raw(handover_ecdh_key.public());
        self.handover_ecdh_key = Some(handover_ecdh_key);

        let challenge = request.decode_challenge().map_err(as_status)?;
        let dev_mode = challenge.dev_mode;
        // generate local attestation report to ensure the handover ceseals are on the same machine
        let sgx_local_report = if !dev_mode {
            let its_target_info = unsafe {
                sgx_api_lite::decode(&challenge.sgx_target_info)
                    .map_err(|_| anyhow!("Invalid client sgx target info"))?
            };
            // the report data does not matter since we only care about the origin
            let report = sgx_api_lite::report(its_target_info, &[0; 64])
                .map_err(|_| anyhow!("Failed to create client LA report"))?;
            sgx_api_lite::encode(&report).to_vec()
        } else {
            info!("Omit client LA report for dev mode challenge");
            vec![]
        };

        let challenge_handler = ChallengeHandlerInfo { challenge, sgx_local_report, ecdh_pubkey };
        let handler_hash = sp_core::hashing::blake2_256(&challenge_handler.encode());
        let attestation = if !dev_mode {
            let a = self
                .ceseal_client
                .create_attestation_report(&handler_hash)
                .await
                .map_err(as_status)?;
            Some(pb::Attestation {
                provider: a.provider,
                encoded_report: a.encoded_report,
                timestamp: a.timestamp,
            })
        } else {
            info!("Omit client RA report for dev mode challenge");
            None
        };

        Ok(pb::HandoverChallengeResponse::new(challenge_handler, attestation))
    }

    /// Key Handover Client: Receive encrypted worker key
    pub fn handover_receive(&self, request: pb::HandoverWorkerKey) -> Result<()> {
        let encrypted_worker_key = request.decode_worker_key()?;

        let dev_mode = encrypted_worker_key.dev_mode;
        // verify RA report
        if !dev_mode {
            let worker_key_hash = sp_core::hashing::blake2_256(&encrypted_worker_key.encode());
            let raw_attestation = request.attestation.ok_or_else(|| anyhow!("Server attestation not found"))?;
            let attn_to_validate = Option::<AttestationReport>::decode(&mut &raw_attestation.encoded_report[..])
                .map_err(|_| anyhow!("Decode server attestation failed"))?;
            validate_attestation_report(attn_to_validate, &worker_key_hash, unix_now(), false, vec![], false)
                .map_err(|_| anyhow!("Invalid server RA report"))?;
        } else {
            info!("Skip server RA report check for dev mode key");
        }

        let encrypted_key = encrypted_worker_key.encrypted_key;
        let my_ecdh_key = self
            .handover_ecdh_key
            .as_ref()
            .ok_or_else(|| anyhow!("Handover ecdhkey not initialized"))?;
        let secret = key_share::decrypt_secret_from(
            my_ecdh_key,
            &encrypted_key.ecdh_pubkey.0,
            &encrypted_key.encrypted_key,
            &encrypted_key.iv,
        )?;

        // only seal if the key is successfully updated
        ceseal
            .save_runtime_data(
                encrypted_worker_key.genesis_block_hash,
                sr25519::Pair::restore_from_secret_key(&match secret {
                    SecretKey::Sr25519(key) => key,
                    _ => panic!("Expected sr25519 key, but got rsa key."),
                }),
                false, // we are not sure whether this key is injected
                dev_mode,
            )
            .map_err(from_display)?;

        // clear cached RA report and handover ecdh key to prevent replay
        ceseal_client.runtime_info = None;
        self.handover_ecdh_key = None;
        Ok(())
    }
}
